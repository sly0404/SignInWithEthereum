var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/**
 * thrown by the RecordStore.fromString parser.
 */
export function RecordStoreInvalidSynthax(message) {
    this.name = "RecordStoreInvalidSynthax";
    this.message = message;
    this.stack = new Error().stack;
}
RecordStoreInvalidSynthax.prototype = new Error();
/**
 * thrown by the replayer if the queue is empty
 */
export function RecordStoreQueueEmpty() {
    this.name = "RecordStoreQueueEmpty";
    this.message = "EOF: no more APDU to replay";
    this.stack = new Error().stack;
}
RecordStoreQueueEmpty.prototype = new Error();
/**
 * thrown by replayer if it meets an unexpected apdu
 */
export function RecordStoreWrongAPDU(expected, got, line) {
    this.name = "RecordStoreWrongAPDU";
    this.message = "wrong apdu to replay line ".concat(line, ". Expected ").concat(expected, ", Got ").concat(got);
    this.expectedAPDU = expected;
    this.gotAPDU = got;
    this.stack = new Error().stack;
}
RecordStoreWrongAPDU.prototype = new Error();
/**
 * thrown by ensureQueueEmpty
 */
export function RecordStoreRemainingAPDU(expected) {
    this.name = "RecordStoreRemainingAPDU";
    this.message = "replay expected more APDUs to come:\n".concat(expected);
    this.stack = new Error().stack;
}
RecordStoreRemainingAPDU.prototype = new Error();
var defaultOpts = {
    autoSkipUnknownApdu: false,
    warning: function (log) { return console.warn(log); }
};
/**
 * a RecordStore is a stateful object that represents a queue of APDUs.
 * It is both used by replayer and recorder transports and is the basic for writing Ledger tests with a mock device.
 */
var RecordStore = /** @class */ (function () {
    function RecordStore(queue, opts) {
        var _this = this;
        this.passed = 0;
        /**
         * check if there is no more APDUs to replay
         */
        this.isEmpty = function () { return _this.queue.length === 0; };
        this.queue = queue || [];
        this.opts = __assign(__assign({}, defaultOpts), opts);
    }
    /**
     * Record an APDU (used by createTransportRecorder)
     * @param {Buffer} apdu input
     * @param {Buffer} out response
     */
    RecordStore.prototype.recordExchange = function (apdu, out) {
        this.queue.push([apdu.toString("hex"), out.toString("hex")]);
    };
    /**
     * Replay an APDU (used by createTransportReplayer)
     * @param apdu
     */
    RecordStore.prototype.replayExchange = function (apdu) {
        var _a = this, queue = _a.queue, opts = _a.opts;
        var apduHex = apdu.toString("hex");
        for (var i = 0; i < queue.length; i++) {
            var head = queue[i];
            var line = 2 * (this.passed + i);
            if (apduHex === head[0]) {
                ++this.passed;
                this.queue = queue.slice(i + 1);
                return Buffer.from(head[1], "hex");
            }
            else {
                if (opts.autoSkipUnknownApdu) {
                    opts.warning("skipped unmatched apdu (line " +
                        line +
                        " â€“ expected " +
                        head[0] +
                        ")");
                    ++this.passed;
                }
                else {
                    throw new RecordStoreWrongAPDU(head[0], apduHex, line);
                }
            }
        }
        this.queue = [];
        throw new RecordStoreQueueEmpty();
    };
    /**
     * Check all APDUs was replayed. Throw if it's not the case.
     */
    RecordStore.prototype.ensureQueueEmpty = function () {
        if (!this.isEmpty()) {
            throw new RecordStoreRemainingAPDU(this.toString());
        }
    };
    /**
     * Print out the series of apdus
     */
    RecordStore.prototype.toString = function () {
        return (this.queue
            .map(function (_a) {
            var _b = __read(_a, 2), send = _b[0], receive = _b[1];
            return "=> ".concat(send, "\n<= ").concat(receive);
        })
            .join("\n") + "\n");
    };
    /**
     * Create a RecordStore by parsing a string (a series of => HEX\n<= HEX)
     * @param {string} series of APDUs
     * @param {$Shape<RecordStoreOptions>} opts
     */
    RecordStore.fromString = function (str, opts) {
        var queue = [];
        var value = [];
        str
            .split("\n")
            .map(function (line) { return line.replace(/ /g, ""); })
            .filter(function (o) { return o; })
            .forEach(function (line) {
            if (value.length === 0) {
                var m = line.match(/^=>([0-9a-fA-F]+)$/);
                if (!m) {
                    throw new RecordStoreInvalidSynthax("expected an apdu input");
                }
                value.push(m[1]);
            }
            else {
                var m = line.match(/^<=([0-9a-fA-F]+)$/);
                if (!m) {
                    throw new RecordStoreInvalidSynthax("expected an apdu output");
                }
                value.push(m[1]);
                queue.push([value[0], value[1]]);
                value = [];
            }
        });
        if (value.length !== 0) {
            throw new RecordStoreInvalidSynthax("unexpected end of file");
        }
        return new RecordStore(queue, opts);
    };
    return RecordStore;
}());
export { RecordStore };
//# sourceMappingURL=RecordStore.js.map